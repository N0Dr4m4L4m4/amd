-----------------------------------------------
-- Delete eventually existing objects ---------
-----------------------------------------------
DROP TRIGGER IF EXISTS trig_del_rating on video;
DROP TRIGGER IF EXISTS trig_also_del_film on film_related_person;

DROP FUNCTION IF EXISTS also_del_film();

DROP FUNCTION IF EXISTS check_user(TEXT);
DROP FUNCTION IF EXISTS change_username(TEXT, TEXT);
DROP FUNCTION IF EXISTS insert_video(TEXT, INT, TEXT[], INT, INT, INT, INT, TEXT);
DROP FUNCTION IF EXISTS insert_video_role(TEXT, INT, TEXT, TEXT, TEXT[]);
DROP FUNCTION IF EXISTS show_all_videos();
DROP FUNCTION IF EXISTS show_films_seasons(TEXT);
DROP FUNCTION IF EXISTS show_episodes(TEXT, INT);
DROP FUNCTION IF EXISTS show_film_attributes(TEXT, INT);
DROP FUNCTION IF EXISTS show_film_rating(TEXT, INT, TEXT);
DROP FUNCTION IF EXISTS show_to_film_related_persons(TEXT, INT);
DROP FUNCTION IF EXISTS update_video(TEXT, int, TEXT, INT, TEXT[], INT, INT, INT, INT, TEXT);
DROP FUNCTION IF EXISTS del_series(TEXT);
DROP FUNCTION IF EXISTS del_season(TEXT, INT);
DROP FUNCTION IF EXISTS del_video(TEXT, INT);
DROP FUNCTION IF EXISTS insert_person(TEXT, TEXT, DATE, VARCHAR(1));
DROP FUNCTION IF EXISTS show_all_persons();
DROP FUNCTION IF EXISTS show_person(TEXT, TEXT);
DROP FUNCTION IF EXISTS update_person(TEXT, TEXT, TEXT, TEXT, DATE, VARCHAR(1));
DROP FUNCTION IF EXISTS del_person(TEXT, TEXT, DATE, VARCHAR(1));
DROP FUNCTION IF EXISTS edit_rating(TEXT, INT, TEXT, INT);
DROP FUNCTION IF EXISTS show_all_ratings();
DROP FUNCTION IF EXISTS genre_rating(TEXT);
DROP FUNCTION IF EXISTS suggestion_all(TEXT);
DROP FUNCTION IF EXISTS suggestion(TEXT);

DROP TABLE IF EXISTS Acts;
DROP TABLE IF EXISTS rating;
DROP TABLE IF EXISTS video;
DROP TABLE IF EXISTS benutzer;
DROP TABLE IF EXISTS film_related_person;



-----------------------------------------------
-- Create Tables ------------------------------
-----------------------------------------------
-- Video --
CREATE TABLE video(
    title TEXT NOT NULL,
    release_year int NOT NULL,
    genre text[],
    min_age int NOT NULL CHECK(min_age = 0 OR min_age = 6 OR min_age = 12 OR min_age = 16 OR min_age = 18),
    duration INT NOT NULL,
    episode_nr INT CHECK(episode_nr > 0),
    season_nr INT  CHECK(season_nr > 0),
    series_name text not NULL,
    PRIMARY KEY(title, release_year)
);

-- Benutzer --
CREATE table benutzer(
    name TEXT PRIMARY KEY,
    age int NOT NULL CHECK(age > 0)
);

-- Rating --
CREATE TABLE rating(
   title TEXT NOT NULL,
   release_year int NOT NULL,
   name TEXT NOT NULL, --REFERENCES benutzer(id),
   rating int NOT NULL CHECK(rating BETWEEN 1 AND 5),
   PRIMARY KEY(name, title, release_year),
   CONSTRAINT fk_rating_video
      FOREIGN KEY(title, release_year) 
	      REFERENCES video(title, release_year)
	        ON DELETE CASCADE
		ON UPDATE CASCADE,
   CONSTRAINT fk_rating_benutzer
      FOREIGN KEY(name) 
	      REFERENCES benutzer(name)
	        ON DELETE CASCADE
		ON UPDATE CASCADE
);

-- Film related person --
CREATE table film_related_person(
    surname TEXT NOT NULL,
    forname TEXT NOT NULL,
    date_of_birth DATE,
    sex varchar(1) CHECK(sex='m' OR sex='w' OR sex='d'),
    PRIMARY KEY(surname, forname)
    --UNIQUE(surname, forname) --PRIMARY KEY automatisch UNIQUE
);

-- Acts --
CREATE TABLE Acts(
   title TEXT NOT NULL,
   release_year int NOT NULL,
   surname TEXT NOT NULL,
   forname TEXT NOT NULL,
   role text[],
   PRIMARY KEY(surname, forname, title, release_year),
   CONSTRAINT fk_acts_video
      FOREIGN KEY(title, release_year) 
	      REFERENCES video(title, release_year)
	        ON DELETE CASCADE
		ON UPDATE CASCADE,
   CONSTRAINT fk_acts_person
      FOREIGN KEY(surname, forname) 
	      REFERENCES film_related_person(surname, forname)
	        ON DELETE CASCADE --kann evtl weglassen, wegen trigger also_del_film()
		ON UPDATE CASCADE
);

-----------------------------------------------
-- Create Trigger and Trigger functions -------
-----------------------------------------------
-- delete ratings, when film gets deleted --
-- mit Hilfe ON DELETE CASCADE in foreign key constraint ist es einfacher --
-- deswegen auskommentiert --
--CREATE OR REPLACE FUNCTION del_rating() RETURNS TRIGGER AS $$
--  BEGIN
--    DELETE FROM Rating
--      WHERE release_year = old.release_year and title = old.title;
--    RETURN OLD; --OLD important here because before trigger
--  END;
--$$ LANGUAGE plpgsql;
--
--CREATE TRIGGER trig_del_rating BEFORE DELETE ON video
--  FOR EACH ROW
--    EXECUTE PROCEDURE del_rating();
-- statt dieser funktion koennte man auch ON DELETE CASCADE verwenden nach fk_constraint

-- delete film, when film related person gets deleted --
CREATE OR REPLACE FUNCTION also_del_film() RETURNS TRIGGER AS $$
  BEGIN
    FOR i in 1..(SELECT COUNT(*) FROM acts where surname=old.surname and forname=old.forname) LOOP
      DELETE FROM Video
        WHERE release_year = (select release_year from acts where acts.surname = old.surname and acts.forname = old.forname LIMIT 1)
          AND title = (select title from acts where acts.surname = old.surname and acts.forname = old.forname LIMIT 1);
    END LOOP;
    RETURN OLD; --OLD important here because before trigger
  END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trig_also_del_film BEFORE DELETE ON film_related_person
  FOR EACH ROW
    EXECUTE PROCEDURE also_del_film();

-----------------------------------------------
-- Functions ----------------------------------
-----------------------------------------------
-- user management ----------------------------
-- check user login --
CREATE OR REPLACE FUNCTION check_user(IN benutzer_name TEXT) RETURNS TEXT AS $$
  BEGIN
    IF ((select name from benutzer where name=benutzer_name) IS NULL) then
      return 'Benutzer existiert nicht.';
    ELSE
      return 'Herzlich Willkommen ' || benutzer_name || '!';
    END IF;
  END;
$$ LANGUAGE plpgsql;

-- change user name --
CREATE OR REPLACE FUNCTION change_username(IN old_benutzer_name TEXT, IN new_benutzer_name TEXT) RETURNS TEXT AS $$
  BEGIN
    IF ((select name from benutzer where name=old_benutzer_name) IS NULL) then
      return 'Benutzer existiert nicht.';
    ELSIF (old_benutzer_name = new_benutzer_name) then
      return 'Alter und neuer Beutzername sind identisch!';
    ELSE
      UPDATE benutzer
        SET name = new_benutzer_name
          WHERE name = old_benutzer_name;
      return 'Benutzername von ' || old_benutzer_name || ' auf ' || new_benutzer_name || ' gewechselt.';
    END IF;
  END;
$$ LANGUAGE plpgsql;


-- Film Management ----------------------------
-- Film hinzufügen --
CREATE OR REPLACE FUNCTION insert_video(IN tit TEXT, IN rel INT, IN gen TEXT[], IN min INT, IN dur INT, IN epi INT, IN sea INT, IN ser TEXT) RETURNS TABLE(Titel TEXT, Erscheinungsjahr INT, Filmgenre TEXT[], Minimumalter INT, Dauer INT, Episodennr INT, Staffel INT, Reihenname TEXT) AS $$
  BEGIN
    RETURN QUERY
    INSERT INTO video (title, release_year, genre, min_age, duration, episode_nr, season_nr, series_name)
      VALUES(tit, rel, gen, min, dur, epi, sea, ser);
  END;
$$ LANGUAGE plpgsql;

-- Im neu hinzugefügten Film eine mitwirkende Person einfügen --
CREATE OR REPLACE FUNCTION insert_video_role(IN tit TEXT, IN rel INT, IN sur TEXT, IN forn TEXT, IN rol TEXT[]) RETURNS TABLE(Titel TEXT, Erscheinungsjahr INT, Nachname TEXT, Vorname TEXT, Rolle TEXT[]) AS $$
  BEGIN
    RETURN QUERY
    INSERT INTO acts(title,release_year,surname,forname,role) 
      VALUES(tit, rel,sur,forn,rol);
  END;
$$ LANGUAGE plpgsql;

-- Überblick über alle Filme in der Datenbank --
CREATE OR REPLACE FUNCTION show_all_videos() RETURNS table(Filmname text) AS $$
  BEGIN
    RETURN QUERY
    SELECT distinct(series_name) FROM video
    ORDER BY series_name;
  END;
$$ LANGUAGE plpgsql;

-- Überblick über alle Filme aus Filmreihe oder Staffeln aus Serie --
CREATE OR REPLACE FUNCTION show_films_seasons(IN ser TEXT) RETURNS table(Liste text) AS $$
  BEGIN
    IF ((SELECT season_nr FROM video where series_name = ser LIMIT 1) IS NULL) THEN
      RETURN QUERY
      SELECT title FROM video 
        WHERE series_name = ser
	ORDER BY episode_nr, series_name;
    ELSE
      RETURN QUERY
      SELECT CAST(season_nr as TEXT) from video 
        WHERE series_name = ser
	ORDER BY season_nr;
    END IF;
  END;
$$ LANGUAGE plpgsql;

-- Überblick über alle Episoden einer Staffel einer Serie --
CREATE OR REPLACE FUNCTION show_episodes(IN ser TEXT, IN sea INT) RETURNS TABLE(Episodennr INT, Episodenname TEXT) AS $$
  BEGIN
    RETURN QUERY
    SELECT episode_nr, title FROM video
      WHERE series_name = ser AND season_nr = sea
      ORDER BY episode_nr, title;
  END;
$$ LANGUAGE plpgsql;

-- Ausgabe eines Films (zum Ändern von Attributen) --
--CREATE OR REPLACE FUNCTION show_film_attributes(IN tit TEXT, IN rel INT, IN nam TEXT) RETURNS TABLE(Titel TEXT, Erscheinungsjahr INT, Filmgenre TEXT[], Minimumalter INT, Dauer INT, Episodennr INT, Staffel INT, Reihenname TEXT, Bewertung INT) AS $$
--  BEGIN
--    RETURN QUERY
--    SELECT v.*, r.rating FROM video v 
--      JOIN rating r ON (v.title=r.title AND v.release_year=r.release_year)
--      WHERE v.title = tit AND v.release_year = rel AND r.name = nam;
--  END;
--$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION show_film_attributes(IN tit TEXT, IN rel INT) RETURNS TABLE(Titel TEXT, Erscheinungsjahr INT, Filmgenre TEXT[], Minimumalter INT, Dauer INT, Episodennr INT, Staffel INT, Reihenname TEXT) AS $$
  BEGIN
    RETURN QUERY
    SELECT * FROM video v 
      WHERE v.title = tit AND v.release_year = rel;
  END;
$$ LANGUAGE plpgsql;

-- Ausgabe des Rating eines bestimmten Films --
CREATE OR REPLACE FUNCTION show_film_rating(IN tit TEXT, IN rel INT, IN nam TEXT, OUT Resultat INT) AS $$
  BEGIN 
    SELECT r.rating FROM video v 
      JOIN rating r ON (r.title=v.title AND r.release_year=v.release_year)
      INTO Resultat
      WHERE v.title = tit AND v.release_year = rel AND r.name = nam;
  END;
$$ LANGUAGE plpgsql;

-- Ausgabe der in einem bestimmten Film mitwirkenden Personen und deren Rollen --
-- Ausgabe des Rating eines bestimmten Films --
CREATE OR REPLACE FUNCTION show_to_film_related_persons(IN tit TEXT, IN rel INT) RETURNS TABLE (Vorname TEXT, Nachname TEXT, Rollen TEXT[]) AS $$
  BEGIN 
    RETURN QUERY
    SELECT a.surname, a.forname, a.role FROM video v 
      JOIN acts a ON (a.title=v.title AND a.release_year=v.release_year)
      WHERE v.title = tit AND v.release_year = rel;
  END;
$$ LANGUAGE plpgsql;

-- Ändern der Filmattribute --
CREATE OR REPLACE FUNCTION update_video(IN old_tit TEXT, IN old_rel int, IN tit TEXT, IN rel INT, IN gen TEXT[], IN min INT, IN dur INT, IN epi INT, IN sea INT, IN ser TEXT) RETURNS TABLE(Titel TEXT, Erscheinungsjahr INT, Filmgenre TEXT[], Minimumalter INT, Dauer INT, Episodennr INT, Staffel INT, Reihenname TEXT) AS $$
  BEGIN
    RETURN QUERY
    UPDATE video
      SET title = tit,
        release_year = rel,
	genre = gen,
	min_age = min,
	duration = dur,
	episode_nr = epi,
	season_nr = sea,
	series_name = ser
      WHERE title = old_tit and release_year = old_rel
      RETURNING *; --returning updated row
  END;
$$ LANGUAGE plpgsql;

-- Löschen von Filmserien --
CREATE OR REPLACE FUNCTION del_series(IN ser TEXT) RETURNS TABLE(Titel TEXT, Erscheinungsjahr INT, Filmgenre TEXT[], Minimumalter INT, Dauer INT, Episodennr INT, Staffel INT, Reihenname TEXT) AS $$
  BEGIN
    RETURN QUERY
    DELETE FROM video
      WHERE series_name = ser
      RETURNING *; --return deleted elements
  END;
$$ LANGUAGE plpgsql;

-- Löschen von Staffeln --
CREATE OR REPLACE FUNCTION del_season(IN ser TEXT, IN sea INT) RETURNS TABLE(Titel TEXT, Erscheinungsjahr INT, Filmgenre TEXT[], Minimumalter INT, Dauer INT, Episodennr INT, Staffel INT, Reihenname TEXT) AS $$
  BEGIN
    RETURN QUERY
    DELETE FROM video
      WHERE series_name = ser AND season_nr = sea
      RETURNING *; --return deleted elements
  END;
$$ LANGUAGE plpgsql;

-- Löschen von Videos --
CREATE OR REPLACE FUNCTION del_video(IN tit TEXT, IN rel INT) RETURNS TABLE(Titel TEXT, Erscheinungsjahr INT, Filmgenre TEXT[], Minimumalter INT, Dauer INT, Episodennr INT, Staffel INT, Reihenname TEXT) AS $$
  BEGIN
    RETURN QUERY
    DELETE FROM video
      WHERE title = tit AND release_year = rel
      RETURNING *; --return deleted elements
  END;
$$ LANGUAGE plpgsql;

-- Film Person Management ---------------------
-- Person hinzufügen --
CREATE OR REPLACE FUNCTION insert_person(IN sur TEXT, IN forn TEXT, IN dat DATE, IN new_sex VARCHAR(1)) RETURNS TABLE(Nachname TEXT, Vorname TEXT, Geburtstag DATE, Geschlecht VARCHAR(1)) AS $$
  BEGIN
    RETURN QUERY
    INSERT INTO film_related_person(surname, forname, date_of_birth, sex)
      VALUES(sur, forn, dat, new_sex)
      RETURNING *;
  END;
$$ LANGUAGE plpgsql;

-- Überblick über alle Personen in der Datenbank --
CREATE OR REPLACE FUNCTION show_all_persons() RETURNS TABLE(Nachname TEXT, Vorname TEXT, Geburtstag DATE, Geschlecht VARCHAR(1)) AS $$
  BEGIN
    RETURN QUERY
    SELECT * FROM film_related_person
      ORDER BY surname, forname;
  END;
$$ LANGUAGE plpgsql;

-- Ausgabe einer bestimmten Person --
CREATE OR REPLACE FUNCTION show_person(IN sur TEXT, in forn TEXT) RETURNS TABLE(Nachname TEXT, Vorname TEXT, Geburtstag DATE, Geschlecht VARCHAR(1)) AS $$
  BEGIN
    RETURN QUERY
    SELECT * FROM film_related_person
      WHERE surname = sur AND forname = forn;
  END;
$$ LANGUAGE plpgsql;

-- Ändern der Personenattributen --
CREATE OR REPLACE FUNCTION update_person(IN old_sur TEXT, IN old_forn TEXT, IN sur TEXT, IN forn TEXT, IN dat DATE, IN new_sex VARCHAR(1)) RETURNS TABLE(Nachname TEXT, Vorname TEXT, Geburtstag DATE, Geschlecht VARCHAR(1)) AS $$
  BEGIN
    RETURN QUERY
    UPDATE film_related_person
      SET surname = sur,
        forname = forn,
	date_of_birth = dat,
	sex = new_sex
      WHERE surname = old_sur and forname = old_forn
      RETURNING *; --returning updated row
  END;
$$ LANGUAGE plpgsql;

-- Löschen von Personen --
CREATE OR REPLACE FUNCTION del_person(IN sur TEXT, IN forn TEXT) RETURNS TABLE(Nachname TEXT, Vorname TEXT, Geburtstag DATE, Geschlecht VARCHAR(1)) AS $$
  BEGIN
    RETURN QUERY
    DELETE FROM film_related_person
      WHERE surname = sur AND forname = forn
      RETURNING *; --return deleted element
  END;
$$ LANGUAGE plpgsql;

-- Filmbewertungen Management -----------------
-- insert new rating --
CREATE OR REPLACE FUNCTION edit_rating(IN tit TEXT, IN rel INT, IN nam TEXT, IN rat INT) RETURNS TABLE(Titel TEXT, Erscheinungsjahr INT, Benutzer TEXT, Bewertung INT) AS $$
  BEGIN
    IF EXISTS (SELECT * FROM rating WHERE title=tit and release_year=rel and name=nam) THEN
      IF rat IS NULL THEN
        RETURN QUERY
	DELETE FROM rating
	  WHERE title=tit and release_year=rel and name=nam
	  RETURNING *;
      ELSE
        RETURN QUERY
        UPDATE rating
          SET rating=rat
	  WHERE title=tit and release_year=rel and name=nam
          RETURNING *;
      END IF;
    ELSE
      RETURN QUERY
      INSERT INTO rating(title, release_year, name, rating)
        VALUES(tit, rel, nam, rat)
        RETURNING *;
    END IF;
  END;
$$ LANGUAGE plpgsql;

-- Überblick über alle Ratings in der Datenbank --
--CREATE OR REPLACE FUNCTION show_all_ratings() RETURNS TABLE(Titel TEXT, Erscheinungsjahr INT, Benutzer TEXT, Bewertung INT) AS $$
--  BEGIN
--    RETURN QUERY
--    SELECT * FROM rating
--    ORDER BY name, title, release_year;
--  END;
--$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION show_all_ratings() RETURNS TABLE(Titel TEXT, Erscheinungsjahr INT, Durchschnitt NUMERIC) AS $$
  BEGIN
    RETURN QUERY
    SELECT title, release_year, ROUND(AVG(rating), 2) as durchschnitt FROM rating
    GROUP BY (title, release_year)
    ORDER BY durchschnitt DESC;
  END;
$$ LANGUAGE plpgsql;

-- Algorithmus Filmvorschläge -----------------
-- Genre Raiting --
CREATE OR REPLACE FUNCTION genre_rating(IN nam TEXT) RETURNS TABLE(Durchschnitt NUMERIC, Genre TEXT) --TABLE(Titel TEXT, Erscheinungsjahr INT, Filmgenre TEXT[], Minimumalter INT, Dauer INT, Episodennr INT, Staffel INT, Reihenname TEXT)
AS $$
  BEGIN
    -- user hat keine videos bewertet:
    IF (SELECT COUNT(*) FROM rating where name=nam) = 0 THEN
      RETURN;
    -- user hat alle videos bewertet:  
    ELSIF (SELECT COUNT(*) FROM rating where name=nam) = (SELECT COUNT(*) FROM video) THEN
      RETURN;
    ELSE
      RETURN QUERY
      SELECT AVG(r.rating) as average, unnest(v.genre)
        FROM video v JOIN rating r ON (v.title=r.title AND v.release_year=r.release_year)
        WHERE r.name=nam
        GROUP BY unnest(v.genre)
        ORDER BY average ASC;
    END IF;
  END;
$$ LANGUAGE plpgsql;

-- Filmvorschläge (alle Film) --
CREATE OR REPLACE FUNCTION suggestion_all(IN nam TEXT) RETURNS TABLE(Resultat NUMERIC, Titel TEXT, Erscheinungsjahr INT) --TABLE(Titel TEXT, Erscheinungsjahr INT, Filmgenre TEXT[], Minimumalter INT, Dauer INT, Episodennr INT, Staffel INT, Reihenname TEXT)
AS $$
  BEGIN
    RETURN QUERY
    SELECT ROUND(AVG(s.Durchschnitt), 2) AS Resultat, v.title, v.release_year --,v.genre ,s.genre, r.name 
      FROM genre_rating(nam) s 
      JOIN video v ON s.genre = ANY(v.genre)
      --Versuch direkt nach nicht geschauten Filmen zu filtern
      --JOIN rating r ON (v.title=r.title AND v.release_year=r.release_year)
      --WHERE NOT(r.name=nam)
      GROUP BY (v.title, v.release_year)
      ORDER BY Resultat DESC;
  END;
$$ LANGUAGE plpgsql;

-- Filmvorschläge (nur noch nicht geschaute Filme) --
CREATE OR REPLACE FUNCTION suggestion(IN nam TEXT) RETURNS TABLE(Resultat NUMERIC, Titel TEXT, Erscheinungsjahr INT) --TABLE(Titel TEXT, Erscheinungsjahr INT, Filmgenre TEXT[], Minimumalter INT, Dauer INT, Episodennr INT, Staffel INT, Reihenname TEXT)
AS $$
  BEGIN
    RETURN QUERY
    SELECT s.*
      FROM suggestion_all(nam) s 
      LEFT JOIN ( select * from rating where name=nam) r  ON (s.Titel=r.title AND s.Erscheinungsjahr=r.release_year)
      WHERE r.name is NULL
      ORDER BY Resultat DESC;
  END;
$$ LANGUAGE plpgsql;

-----------------------------------------------
-- Insert Dummy Data --------------------------
-----------------------------------------------
INSERT INTO film_related_person(surname, forname, date_of_birth, sex) 
  VALUES('Watson', 'Emma', '1990-04-15', 'w'),
    ('Radcliffe', 'Daniel', '1989-06-23', 'm'),
    ('Pacino', 'Al', '1940-04-25', 'm'),
    ('Hofmann', 'Luis', '1997-06-03', 'm'),
    ('Stiebitz', 'Gina', '1997-11-17', 'w'),
    ('Friese', 'Jantje', '1977-01-01', 'w'),
    ('Mustermann', 'Max', '1987-12-22', 'm'),
    ('Musterdreher', 'Rainer', '2003-02-26', 'm'),
    ('Pauke', 'Frauke', '1956-08-30', 'w'),
    ('Musterfilmerin', 'Marie', '1944-07-01', 'w');

INSERT INTO benutzer(name,age)
  VALUES('Mats',5),
    ('Axel',23),
    ('Robin',23),
    ('Sabine',55),
    ('Tina',16);

INSERT INTO video (title, release_year, genre, min_age, duration, episode_nr, season_nr, series_name)
  VALUES('Harry Potter und der Stein der Weisen',2001,'{Fantasy}',12,140, 1, NULL, 'Harry Potter'),
    ('Harry Potter und die Kammer des Schreckens',2002,'{Fantasy}',12,154, 2, NULL, 'Harry Potter'),
    ('Harry Potter und der Gefangene von Askaban',2004,'{Fantasy}',12,132, 3, NULL, 'Harry Potter'),
    ('Harry Potter und der Feuerkelch',2005,'{Fantasy}',12,118, 4, NULL, 'Harry Potter'),    
    ('Geheimnisse',2017,'{Science-Fiction,Mystery,Thriller}',12,54, 1, 1, 'Dark'),
    ('Die Reisenden',2018,'{Science-Fiction,Mystery,Thriller}',12,49, 4, 2, 'Dark'),
    ('Der Pate',1972,'{Mafia,Krimi,Drama}',18,180, 1, NULL, 'Der Pate'),
    ('Kindisch',1988,'{Kind,Fantasy,Animation}',0,67, 1, NULL, 'Kinderfilmreihe'),
    ('Musterfilm',2004,'{Action,Krimi,Drama}',18,180, 1, NULL, 'Stirb Langsam'),
    ('Romantische Episode',2019,'{Drama,Romantik,Herzschmerz}',0,128, 12, 1, 'Moderne Romanzen');

INSERT INTO rating(title,release_year,name,rating) 
  VALUES('Der Pate',1972,'Axel',4),
  ('Geheimnisse',2017,'Axel',5),
  ('Die Reisenden',2018,'Axel',5),
  ('Kindisch',1988,'Axel',1),
  ('Musterfilm',2004,'Axel',3),
  ('Harry Potter und der Stein der Weisen',2001,'Robin',3),
  ('Harry Potter und der Gefangene von Askaban',2004,'Robin',5),
  ('Musterfilm',2004,'Robin',3),
  ('Romantische Episode',2019,'Robin',2),
  ('Harry Potter und die Kammer des Schreckens',2002,'Robin',5),
  ('Romantische Episode',2019,'Sabine',5),
  ('Musterfilm',2004,'Sabine',5),
  ('Harry Potter und der Gefangene von Askaban',2004,'Sabine',1),
  ('Harry Potter und der Stein der Weisen',2001,'Sabine',2),
  ('Der Pate',1972,'Sabine',4),
  ('Harry Potter und der Stein der Weisen',2001,'Tina',1),
  ('Harry Potter und die Kammer des Schreckens',2002,'Tina',4),
  ('Harry Potter und der Gefangene von Askaban',2004,'Tina',2),
  ('Harry Potter und der Feuerkelch',2005,'Tina',1),
  ('Geheimnisse',2017,'Tina',3),
  ('Die Reisenden',2018,'Tina',2),
  ('Der Pate',1972,'Tina',4),
  ('Kindisch',1988,'Tina',5),
  ('Musterfilm',2004,'Tina',4),
  ('Romantische Episode',2019,'Tina',1);

INSERT INTO acts(title,release_year,surname,forname,role) 
  VALUES('Harry Potter und der Stein der Weisen',2001, 'Watson', 'Emma', '{Schauspieler}'),
    ('Harry Potter und die Kammer des Schreckens',2002, 'Watson', 'Emma', '{Schauspieler}'),
    ('Harry Potter und der Gefangene von Askaban',2004, 'Watson', 'Emma', '{Schauspieler}'),
    ('Harry Potter und der Feuerkelch',2005, 'Watson', 'Emma', '{Schauspieler}'),
    ('Harry Potter und der Stein der Weisen',2001, 'Radcliffe', 'Daniel', '{Schauspieler}'),
    ('Harry Potter und die Kammer des Schreckens',2002, 'Radcliffe', 'Daniel', '{Schauspieler}'),
    ('Harry Potter und der Gefangene von Askaban',2004, 'Radcliffe', 'Daniel', '{Schauspieler}'),
    ('Harry Potter und der Feuerkelch',2005, 'Radcliffe', 'Daniel', '{Schauspieler}'),
    ('Geheimnisse',2017, 'Hofmann', 'Luis', '{Schauspieler}'),
    ('Die Reisenden',2018, 'Hofmann', 'Luis', '{Schauspieler}'),
    ('Geheimnisse',2017, 'Stiebitz', 'Gina', '{Schauspieler}'),
    ('Die Reisenden',2018, 'Stiebitz', 'Gina', '{Schauspieler}'),
    ('Geheimnisse',2017, 'Friese', 'Jantje', '{Drehbuchautor,Produzent}'),
    ('Die Reisenden',2018, 'Friese', 'Jantje', '{Drehbuchautor,Produzent}'),
    ('Der Pate',1972, 'Pacino', 'Al', '{Schauspieler,Regisseur,Produzent}'),
    ('Die Reisenden',2018, 'Mustermann', 'Max', '{Schauspieler}'),
    ('Musterfilm',2004, 'Mustermann', 'Max', '{Schauspieler}'),
    ('Geheimnisse',2017, 'Mustermann', 'Max', '{Schauspieler}'),
    ('Kindisch',1988, 'Musterdreher', 'Rainer', '{Kameramann,Schauspieler}'),
    ('Geheimnisse',2017, 'Musterdreher', 'Rainer', '{Kameramann}'),
    ('Romantische Episode',2019, 'Musterdreher', 'Rainer', '{Kameramann}'),
    ('Kindisch',1988,'Pauke','Frauke', '{Schauspieler}'),
    ('Der Pate',1972,'Pauke','Frauke', '{Schauspieler}'),
    ('Romantische Episode',2019,'Pauke','Frauke', '{Schauspieler}'),
    ('Kindisch',1988, 'Hofmann', 'Luis', '{Schauspieler}'),
    ('Musterfilm',2004, 'Hofmann', 'Luis', '{Schauspieler}'),
    ('Romantische Episode',2019, 'Hofmann', 'Luis', '{Schauspieler}'),
    ('Der Pate',1972,'Musterfilmerin','Marie', '{Produzent,Kameramann}'),
    ('Musterfilm',2004,'Musterfilmerin','Marie', '{Kameramann}'),
    ('Die Reisenden',2018,'Musterfilmerin','Marie', '{Kameramann}');

-----------------------------------------------
-- Testing ------------------------------------
-----------------------------------------------
-- Check User login, --
-- then 'Herzlich Willkommen "name"!' or 'Benutzer existiert nicht!' sollte angezeigt werden --
--select * from check_user('Axel');

-- change username, --
-- then username should be changed and put out or 'alter und neuer benutzername sind identisch' --
--select * from change_username('Axel', 'Axelino');
--select * from change_username('raineirn', 'Axelino');
--select * from change_username('Axel', 'Axel');

-- delete film, --
-- then ratings in rating should be deleted too --
--delete from video where title='Harry Potter und der Stein der Weisen' and release_year = 2001;
--select * from video;
--select * from rating;

-- delete film rating, --
-- then film in video should not be deleted --
--delete from rating where title='Harry Potter und der Stein der Weisen' and release_year = 2001;
--select * from video;
--select * from rating;

-- delete film related person, --
-- then role in acts and film in video should be deleted too --
--delete from film_related_person where surname='Watson';
--select * from film_related_person;
--select * from acts;
--select * from video;

-- Anzeige von allen Filmen mit Genre Fantasy --
-- then sollten auch alle angezeigt werden mit Fantasy --
--select * from video where 'Fantasy' = ANY(genre)

-- Aufruf Funktion zum Hinzufügen eines Films samt im Film mitwikrender Person --
-- then sollte Eintrag eingefügt werden
--select insert_video('Harry Potter und der Test',2001,'{Fantasy,Abenteuer}',12,140, 1, NULL, 'Harry Potter');
--select insert_video_role('Harry Potter und der Test',2001,'Watson','Emma', '{Schauspieler, Statist}');
--select insert_video('Zweite Dark Folge',2017,'{Science-Fiction,Mystery,Thriller}',12,52, 2, 1, 'Dark');

-- show_all_videos --
--select * from show_all_videos();

-- show film from filmreihe or season_nr from series, --
--select * from show_films_seasons('Harry Potter');
--select * from show_films_seasons('Dark');

-- show episodes of season of series --
--select * from show_episodes('Dark', 1);

-- show film attributes, --
-- then all film attributes and rating of the person (if exists) should be put out --
--select * from show_film_attributes('Geheimnisse', 2017);
--select * from show_film_attributes('Geheimnisse', 12341234);

-- show film rating from a certain movie, --
-- then rating should be shown if exists --
--select * from show_film_rating('Geheimnisse', 2017, 'Axel');
--select * from show_film_rating('Geheimnisse', 2017, 'Mats');

-- show to a specific film related persons, --
-- then persons should be put out as table --
--select * from show_to_film_related_persons('Geheimnisse', 2017);
--select * from show_to_film_related_persons('Der Pate', 1972);
--select * from show_to_film_related_persons('Der nicht vorhandene Film', 1972);

-- update video attributes --
--select * from update_video('Musterfilm',2004, 'Musterfilmchen',2014,'{Action,Fantasy,Drama}',16,130, 1, NULL, 'Stirb Langsamer')

-- delete series --
-- then all Harray Potter movies should be deleted and put out --
--select * from del_series('Harry Potter');

-- delete season --
-- then all Dark episodes from season 1 should be deleted and put out --
--select * from del_season('Dark', 1);

-- delete video --
-- then the Dark episode 'Geheimnisse' from season 1 should be deleted and put out --
--select * from del_video('Geheimnisse', 2017);

-- insert film related person --
-- then person should be inserted and put out --
--select * from insert_person('Tester', 'Hans', '1999-12-12', 'd')

-- show all persons --
-- then all persons should be printed out --
--select * from show_all_persons();

-- show single person --
--select * from show_person('Watson', 'Emma');
--select * from show_person('Watson', 'Emaasfda');

-- update person --
-- then person attributes should be updated and put out --
--select * from update_person('Watson', 'Emma', 'Watdaughter', 'Remy', NULL, NULL);

-- delete person --
-- then person should be deleted and put out --
--select * from del_person('Stiebitz', 'Gina');

-- insert rating --
-- then rating should be inserted if not existing, or updated if existing and new rating is not null otherwise deleted --
--select * from edit_rating('Geheimnisse', 2017, 'Mats', 5); --insert new rating
--select * from edit_rating('Geheimnisse', 2017, 'Mats', 3); --update rating
--select * from edit_rating('Geheimnisse', 2017, 'Mats', NULL); --delete rating

-- show all ratings --
-- then all ratings should be shown --
--select * from show_all_ratings();

-- Genre Raiting ausprobieren --
-- 1) User, der keine Bewertungen abgegeben hat -> Mats --
-- then keine Rückgabe sollte outcome sein --
--select * from genre_rating('Mats');
-- 2) User, der alle Bewertungen abgegeben hat -> Tina --
-- then keine Rückgabe sollte outcome sein --
--select * from genre_rating('Tina');
-- 3) User der einige Bewertungen abgegeben hat -> Axel --
-- then keine Rückgabe sollte outcome sein --
--select * from genre_rating('Axel');

-- Filmvorschläge (alle Filme) ausprobieren --
-- 1) User, der keine Bewertungen abgegeben hat -> Mats --
-- then keine Rückgabe sollte outcome sein --
--select * from suggestion_all('Mats');
-- 2) User, der alle Bewertungen abgegeben hat -> Tina --
-- then keine Rückgabe sollte outcome sein --
--select * from suggestion_all('Tina');
-- 3) User der einige Bewertungen abgegeben hat -> Axel --
-- then keine Rückgabe sollte outcome sein --
--select * from suggestion_all('Axel');

-- Filmvorschläge (nur noch nicht geschaute Filme) ausprobieren --
-- 1) User, der keine Bewertungen abgegeben hat -> Mats --
-- then keine Rückgabe sollte outcome sein --
--select * from suggestion('Mats');
-- 2) User, der alle Bewertungen abgegeben hat -> Tina --
-- then keine Rückgabe sollte outcome sein --
--select * from suggestion('Tina');
-- 3) User der einige Bewertungen abgegeben hat -> Axel --
-- then keine Rückgabe sollte outcome sein --
--select * from suggestion('Axel');
-- Achtung: da basierend auf Genre, kann es sein, dass keine Vorschläge, 
  -- da User das Genre von nicht geschauten Filmen nicht mit anderen Filmen bewertet hat

